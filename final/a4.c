#pragma config(Motor,  motor12,          rampMotor, tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor11,          leftLiftMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          leftMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          intake,     tmotorVexIQ, PIDControl, encoder)

//#pragma config(Motor,  motor9,          basketMotor,   tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
  This program will use the VEX IQ Wirless Controller to drive your Clawbot. This program uses
  If/Else statements to provide a "threshold" for the transmitter - this allows your robot to
  come to a stop even if the joysticks on the Wireless Controller haven't perfectly returned to
  their zero position.

  Note: You will have to set ROBOTC to enable "Wireless Control" to use the VEX IQ joystick.

                            ROBOT CONFIGURATION: VEX IQ Clawbot
    MOTORS & SENSORS:
    [I/O Port]          [Name]              [Type]                			[Location]
    Port 1        			leftMotor           VEX IQ Motor		      			Left side motor
    Port 6       				rightMotor          VEX IQ Motor		      			Right side motor (reversed)
		Port 10							armMotor						VEX IQ Motor								Arm Up/Down motor
		Port 11							clawMotor						VEX IQ Motor								Claw Open/Close motor
------------------------------------------------------------------------------------------------*/
//#pragma config(Motor,  motor6,          intake,        tmotorVexIQ, PIDControl, encoder)



task main()
{
				// Reset all motors.
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);
				resetMotorEncoder(rampMotor);

				setMotorTarget(leftMotor, -260, 100); // -300
				waitUntilMotorStop(leftMotor);
				resetMotorEncoder(leftMotor);

				// Go backward closer to the cube
				setMotorTarget(leftMotor, -450, 100);
				setMotorTarget(rightMotor, -450, 100);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				// Slower and closer to the cube
				setMotorTarget(leftMotor, -50, 50);
				setMotorTarget(rightMotor, -50, 50);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				// Lift the ramp
				setMotorTarget(rampMotor, -500, 100); // -520
				waitUntilMotorStop(rampMotor);
				resetMotorEncoder(rampMotor);

				// Go forward
				setMotorTarget(leftMotor, 350, 50);
				setMotorTarget(rightMotor, 350, 50);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				// Turn
				setMotorTarget(leftMotor, -150, 40);
				setMotorTarget(rightMotor, 150, 40);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				// Go backward closer to the tall tower
				setMotorTarget(leftMotor, -340, 50);
				setMotorTarget(rightMotor, -340, 50); // -345
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				// Lower the ramp
				// setMotorTarget(rampMotor, 250, 50); // Original
				setMotorTarget(rampMotor, 200, 50); // Original
				waitUntilMotorStop(rampMotor);
				resetMotorEncoder(rampMotor);

				// Go forward
				/*
				setMotorTarget(leftMotor, 150, 50);
				setMotorTarget(rightMotor, 150, 50);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);
	*/
} // end of task main ()222222
